{"version":3,"file":"index.umd.js","sources":["../src/lib/jobRunner.ts","../src/lib/createWorkerBlobUrl.ts","../src/lib/remoteDepsParser.ts","../src/lib/status.ts","../src/useWorker.ts","../src/hook/useDeepCallback.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport { TRANSFERABLE_TYPE } from 'src/useWorker'\n\ninterface JOB_RUNNER_OPTIONS {\n  fn: Function,\n  transferable: TRANSFERABLE_TYPE\n}\n\n/**\n * This function accepts as a parameter a function \"userFunc\"\n * And as a result returns an anonymous function.\n * This anonymous function, accepts as arguments,\n * the parameters to pass to the function \"useArgs\" and returns a Promise\n * This function can be used as a wrapper, only inside a Worker\n * because it depends by \"postMessage\".\n *\n * @param {Function} userFunc {Function} fn the function to run with web worker\n *\n * @returns {Function} returns a function that accepts the parameters\n * to be passed to the \"userFunc\" function\n */\nconst jobRunner = (options: JOB_RUNNER_OPTIONS): Function => (e: MessageEvent) => {\n  const [userFuncArgs] = e.data as [any[]]\n  return Promise.resolve(options.fn(...userFuncArgs))\n    .then(result => {\n      const isTransferable = (val: any) => (\n        ('ArrayBuffer' in self && val instanceof ArrayBuffer)\n        || ('MessagePort' in self && val instanceof MessagePort)\n        || ('ImageBitmap' in self && val instanceof ImageBitmap)\n        || ('OffscreenCanvas' in self && val instanceof OffscreenCanvas)\n      )\n      const transferList: any[] = options.transferable === 'auto' && isTransferable(result) ? [result] : []\n      // @ts-ignore\n      postMessage(['SUCCESS', result], transferList)\n    })\n    .catch(error => {\n      // @ts-ignore\n      postMessage(['ERROR', error])\n    })\n}\n\nexport default jobRunner\n","// import isoworker from 'isoworker'\nimport { TRANSFERABLE_TYPE } from '../useWorker'\nimport jobRunner from './jobRunner'\nimport remoteDepsParser from './remoteDepsParser'\n\n/**\n * Converts the \"fn\" function into the syntax needed to be executed within a web worker\n *\n * @param {Function} fn the function to run with web worker\n * @param {Array.<String>} deps array of strings, imported into the worker through \"importScripts\"\n *\n * @returns {String} a blob url, containing the code of \"fn\" as a string\n *\n * @example\n * createWorkerBlobUrl((a,b) => a+b, [])\n * // return \"onmessage=return Promise.resolve((a,b) => a + b)\n * .then(postMessage(['SUCCESS', result]))\n * .catch(postMessage(['ERROR', error])\"\n */\nconst createWorkerBlobUrl = (\n  fn: Function, deps: string[], transferable: TRANSFERABLE_TYPE, /* localDeps: () => unknown[], */\n) => {\n  // const [context] = isoworker.createContext(localDeps)\n  const blobCode = `\n    ${remoteDepsParser(deps)};\n    onmessage=(${jobRunner})({\n      fn: (${fn}),\n      transferable: '${transferable}'\n    })\n  `\n  const blob = new Blob([blobCode], { type: 'text/javascript' })\n  const url = URL.createObjectURL(blob)\n  return url\n}\n\nexport default createWorkerBlobUrl\n","/**\n *\n * Concatenates the remote dependencies into a comma separated string.\n * this string will then be passed as an argument to the \"importScripts\" function\n *\n * @param {Array.<String>}} deps array of string\n * @returns {String} a string composed by the concatenation of the array\n * elements \"deps\" and \"importScripts\".\n *\n * @example\n * remoteDepsParser(['http://js.com/1.js', 'http://js.com/2.js']) // importScripts('http://js.com/1.js', 'http://js.com/2.js')\n */\nconst remoteDepsParser = (deps: string[]) => {\n  if (deps.length === 0) return ''\n\n  const depsString = (deps.map(dep => `'${dep}'`)).toString()\n  return `importScripts(${depsString})`\n}\n\nexport default remoteDepsParser\n","export enum WORKER_STATUS {\n  PENDING = 'PENDING',\n  SUCCESS = 'SUCCESS',\n  RUNNING = 'RUNNING',\n  ERROR = 'ERROR',\n  TIMEOUT_EXPIRED = 'TIMEOUT_EXPIRED',\n}\n\nexport default WORKER_STATUS\n","import React from \"react\";\nimport createWorkerBlobUrl from \"./lib/createWorkerBlobUrl\";\nimport WORKER_STATUS from \"./lib/status\";\nimport { useDeepCallback } from \"./hook/useDeepCallback\";\n\ntype WorkerController = {\n  status: WORKER_STATUS;\n  kill: Function;\n};\n\nexport enum TRANSFERABLE_TYPE {\n  AUTO = \"auto\",\n  NONE = \"none\",\n}\n\ntype Options = {\n  timeout?: number;\n  remoteDependencies?: string[];\n  autoTerminate?: boolean;\n  transferable?: TRANSFERABLE_TYPE;\n  // localDependencies?: () => unknown[];\n};\n\nconst PROMISE_RESOLVE = \"resolve\";\nconst PROMISE_REJECT = \"reject\";\nconst DEFAULT_OPTIONS: Options = {\n  timeout: undefined,\n  remoteDependencies: [],\n  autoTerminate: true,\n  transferable: TRANSFERABLE_TYPE.AUTO,\n  // localDependencies: () => [],\n};\n\n/**\n *\n * @param {Function} fn the function to run with web worker\n * @param {Object} options useWorker option params\n */\nexport const useWorker = <T extends (...fnArgs: any[]) => any>(\n  fn: T,\n  options: Options = DEFAULT_OPTIONS\n) => {\n  const [workerStatus, _setWorkerStatus] = React.useState<WORKER_STATUS>(\n    WORKER_STATUS.PENDING\n  );\n  const worker = React.useRef<Worker & { _url?: string }>();\n  const isRunning = React.useRef(false);\n  const promise = React.useRef<{\n    [PROMISE_REJECT]?: (result: ReturnType<T> | ErrorEvent) => void;\n    [PROMISE_RESOLVE]?: (result: ReturnType<T>) => void;\n  }>({});\n  const timeoutId = React.useRef<number>();\n\n  const setWorkerStatus = React.useCallback((status: WORKER_STATUS) => {\n    isRunning.current = status === WORKER_STATUS.RUNNING;\n    _setWorkerStatus(status);\n  }, []);\n\n  const killWorker = React.useCallback(() => {\n    if (worker.current?._url) {\n      worker.current.terminate();\n      URL.revokeObjectURL(worker.current._url);\n      promise.current = {};\n      worker.current = undefined;\n      window.clearTimeout(timeoutId.current);\n    }\n  }, []);\n\n  const onWorkerEnd = React.useCallback(\n    (status: WORKER_STATUS) => {\n      const terminate =\n        options.autoTerminate != null\n          ? options.autoTerminate\n          : DEFAULT_OPTIONS.autoTerminate;\n\n      if (terminate) {\n        killWorker();\n      }\n      setWorkerStatus(status);\n    },\n    [options.autoTerminate, killWorker, setWorkerStatus]\n  );\n\n  const generateWorker = useDeepCallback(() => {\n    const {\n      remoteDependencies = DEFAULT_OPTIONS.remoteDependencies,\n      timeout = DEFAULT_OPTIONS.timeout,\n      transferable = DEFAULT_OPTIONS.transferable,\n      // localDependencies = DEFAULT_OPTIONS.localDependencies,\n    } = options;\n\n    const blobUrl = createWorkerBlobUrl(\n      fn,\n      remoteDependencies!,\n      transferable! /*, localDependencies!*/\n    );\n    const newWorker: Worker & { _url?: string } = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n\n    newWorker.onmessage = (e: MessageEvent) => {\n      const [status, result] = e.data as [WORKER_STATUS, ReturnType<T>];\n\n      switch (status) {\n        case WORKER_STATUS.SUCCESS:\n          promise.current[PROMISE_RESOLVE]?.(result);\n          onWorkerEnd(WORKER_STATUS.SUCCESS);\n          break;\n        default:\n          promise.current[PROMISE_REJECT]?.(result);\n          onWorkerEnd(WORKER_STATUS.ERROR);\n          break;\n      }\n    };\n\n    newWorker.onerror = (e: ErrorEvent) => {\n      promise.current[PROMISE_REJECT]?.(e);\n      onWorkerEnd(WORKER_STATUS.ERROR);\n    };\n\n    if (timeout) {\n      timeoutId.current = window.setTimeout(() => {\n        killWorker();\n        setWorkerStatus(WORKER_STATUS.TIMEOUT_EXPIRED);\n      }, timeout);\n    }\n    return newWorker;\n  }, [fn, options, killWorker]);\n\n  const callWorker = React.useCallback(\n    (...workerArgs: Parameters<T>) => {\n      const { transferable = DEFAULT_OPTIONS.transferable } = options;\n      return new Promise<ReturnType<T>>((resolve, reject) => {\n        promise.current = {\n          [PROMISE_RESOLVE]: resolve,\n          [PROMISE_REJECT]: reject,\n        };\n        const transferList: any[] =\n          transferable === TRANSFERABLE_TYPE.AUTO\n            ? workerArgs.filter(\n                (val: any) =>\n                  (\"ArrayBuffer\" in window && val instanceof ArrayBuffer) ||\n                  (\"MessagePort\" in window && val instanceof MessagePort) ||\n                  (\"ImageBitmap\" in window && val instanceof ImageBitmap) ||\n                  (\"OffscreenCanvas\" in window &&\n                    val instanceof OffscreenCanvas)\n              )\n            : [];\n\n        worker.current?.postMessage([[...workerArgs]], transferList);\n\n        setWorkerStatus(WORKER_STATUS.RUNNING);\n      });\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    },\n    [setWorkerStatus]\n  );\n\n  const workerHook = React.useCallback(\n    (...fnArgs: Parameters<T>) => {\n      const terminate =\n        options.autoTerminate != null\n          ? options.autoTerminate\n          : DEFAULT_OPTIONS.autoTerminate;\n\n      if (isRunning.current) {\n        /* eslint-disable-next-line no-console */\n        console.error(\n          \"[useWorker] You can only run one instance of the worker at a time, if you want to run more than one in parallel, create another instance with the hook useWorker(). Read more: https://github.com/alewin/useWorker\"\n        );\n        return Promise.reject();\n      }\n      if (terminate || !worker.current) {\n        worker.current = generateWorker();\n      }\n\n      return callWorker(...fnArgs);\n    },\n    [options.autoTerminate, generateWorker, callWorker]\n  );\n\n  const workerController = {\n    status: workerStatus,\n    kill: killWorker,\n  };\n\n  React.useEffect(\n    () => () => {\n      killWorker();\n    },\n    [killWorker]\n  );\n\n  return [workerHook, workerController, worker.current] as [\n    typeof workerHook,\n    WorkerController,\n    any\n  ];\n};\n","import React, { DependencyList } from 'react'\nimport dequal from 'dequal'\n\nexport const useDeepCallback = <T extends (...args: any[]) => any>(\n  callback: T, dependencies: DependencyList,\n) => {\n  const prevDependencies = React.useRef<DependencyList>(dependencies)\n  const areDeepsEqual = dequal(prevDependencies.current, dependencies)\n  if (!areDeepsEqual) {\n    prevDependencies.current = dependencies\n  }\n\n  return React.useCallback(callback, prevDependencies.current)\n}\n"],"names":["jobRunner","options","e","Promise","resolve","fn","data","then","result","val","transferList","transferable","self","ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas","postMessage","error","createWorkerBlobUrl","deps","blobCode","length","map","dep","toString","remoteDepsParser","blob","Blob","type","URL","createObjectURL","WORKER_STATUS","TRANSFERABLE_TYPE","DEFAULT_OPTIONS","timeout","undefined","remoteDependencies","autoTerminate","AUTO","callback","dependencies","prevDependencies","React","useState","PENDING","workerStatus","_setWorkerStatus","worker","useRef","isRunning","promise","timeoutId","setWorkerStatus","useCallback","status","current","RUNNING","killWorker","_worker$current","_url","terminate","revokeObjectURL","window","clearTimeout","onWorkerEnd","generateWorker","blobUrl","newWorker","Worker","onmessage","SUCCESS","ERROR","onerror","setTimeout","TIMEOUT_EXPIRED","dequal","callWorker","workerArgs","reject","filter","workerHook","console","workerController","kill","useEffect"],"mappings":"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"}